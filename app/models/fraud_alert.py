"""
Fraud Alert model for detecting, tracking, and managing potential fraud incidents.

This model represents alerts generated by the fraud detection system, providing
comprehensive tracking of suspicious activities, investigation status, and resolution
details. It integrates with other core models (User, Account, Transaction, Card)
to provide a complete view of potential fraud cases.
"""
from datetime import datetime, timezone
from enum import Enum
from typing import Dict, Any, List, Optional, Union, Literal, TypedDict
from uuid import uuid4

from sqlalchemy import (
    Column, Integer, String, Text, ForeignKey, DateTime, 
    Float, Enum as SQLEnum, Index, Boolean, CheckConstraint,
    UniqueConstraint, event, DDL
)
from sqlalchemy.dialects.postgresql import JSONB, UUID
from sqlalchemy.orm import relationship, validates
from sqlalchemy.sql import func, and_, or_

from .base import ModelBase

class FraudAlertType(str, Enum):
    """Types of fraud alerts that can be generated by the system.
    
    Each type represents a different category of suspicious activity that the
    fraud detection system is designed to identify and flag for review.
    """
    # Transaction-related alerts
    HIGH_RISK_TRANSACTION = "high_risk_transaction"
    UNUSUAL_LOCATION = "unusual_location"
    VELOCITY_CHECK = "velocity_check"
    AMOUNT_THRESHOLD = "amount_threshold"
    
    # Account-related alerts
    ACCOUNT_TAKEOVER = "account_takeover"
    SUSPICIOUS_ACCOUNT_ACTIVITY = "suspicious_account_activity"
    CREDENTIAL_STUFFING = "credential_stuffing"
    BRUTE_FORCE_ATTEMPT = "brute_force_attempt"
    
    # Identity-related alerts
    IDENTITY_THEFT = "identity_theft"
    SYNTHETIC_IDENTITY = "synthetic_identity"
    IDENTITY_MISMATCH = "identity_mismatch"
    
    # Payment card alerts
    CARD_NOT_PRESENT = "card_not_present"
    CARD_PRESENT = "card_present"
    CARD_TESTING = "card_testing"
    CARD_CREDENTIAL_COMPROMISE = "card_credential_compromise"
    
    # Application fraud
    APPLICATION_FRAUD = "application_fraud"
    LOAN_FRAUD = "loan_fraud"
    INSURANCE_FRAUD = "insurance_fraud"
    
    # Money movement
    MONEY_LAUNDERING = "money_laundering"
    STRUCTURING = "structuring"
    SMURFING = "smurfing"
    
    # Other fraud types
    FIRST_PARTY_FRAUD = "first_party_fraud"
    PHISHING = "phishing"
    MALWARE = "malware"
    INSIDER_THREAT = "insider_threat"
    
    # System and technical
    DEVICE_RISK = "device_risk"
    IP_REPUTATION = "ip_reputation"
    BEHAVIORAL_ANOMALY = "behavioral_anomaly"
    
    # Catch-all
    OTHER = "other"
    
    @classmethod
    def get_high_risk_types(cls) -> List['FraudAlertType']:
        """Get a list of alert types that are considered high risk."""
        return [
            cls.ACCOUNT_TAKEOVER,
            cls.IDENTITY_THEFT,
            cls.MONEY_LAUNDERING,
            cls.CARD_CREDENTIAL_COMPROMISE,
            cls.INSIDER_THREAT
        ]
    
    @classmethod
    def get_financial_impact_types(cls) -> List['FraudAlertType']:
        """Get alert types that typically involve financial impact."""
        return [
            cls.HIGH_RISK_TRANSACTION,
            cls.AMOUNT_THRESHOLD,
            cls.CARD_NOT_PRESENT,
            cls.CARD_PRESENT,
            cls.LOAN_FRAUD,
            cls.INSURANCE_FRAUD
        ]

class FraudAlertSeverity(str, Enum):
    """Severity levels for fraud alerts.
    
    Determines the urgency and potential impact of the alert, guiding
    the appropriate response and escalation procedures.
    """
    LOW = "low"           # Minor concern, review when possible
    MEDIUM = "medium"     # Moderate concern, review within 24 hours
    HIGH = "high"         # Significant concern, immediate review required
    CRITICAL = "critical" # Severe impact, immediate action required
    
    @classmethod
    def from_risk_score(cls, score: float) -> 'FraudAlertSeverity':
        """Convert a risk score (0-1) to a severity level."""
        if not (0 <= score <= 1):
            raise ValueError("Risk score must be between 0 and 1")
            
        if score >= 0.8:
            return cls.CRITICAL
        elif score >= 0.6:
            return cls.HIGH
        elif score >= 0.4:
            return cls.MEDIUM
        return cls.LnOW

class FraudAlertStatus(str, Enum):
    """Lifecycle status of a fraud alert.
    
    Tracks the current state of an alert as it moves through the
    investigation and resolution workflow.
    """
    # Initial state
    ACTIVE = "active"             # New alert awaiting review
    
    # Investigation states
    ACKNOWLEDGED = "acknowledged" # Alert seen by staff, under review
    INVESTIGATING = "investigating" # Actively being investigated
    ESCALATED = "escalated"       # Requires higher-level review
    
    # Resolution states
    FALSE_POSITIVE = "false_positive" # Determined not to be fraud
    CONFIRMED_FRAUD = "confirmed_fraud"

class FraudAlert(ModelBase):
    """
    Model for tracking and managing fraud alerts generated by the system.
    """
    __tablename__ = 'fraud_alerts'
    
    alert_id = Column(Integer, primary_key=True, autoincrement=True)
    alert_reference = Column(String(50), unique=True, nullable=False, index=True)
    
    # Alert details
    alert_type = Column(SQLEnum(FraudAlertType), nullable=False, index=True)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    
    # Risk assessment
    risk_score = Column(Float, nullable=False)  # 0-1 scale
    severity = Column(SQLEnum(FraudAlertSeverity), nullable=False, index=True)
    confidence = Column(Float)  # 0-1 scale, AI confidence in fraud detection
    
    # Related entities
    user_id = Column(Integer, ForeignKey('users.user_id', ondelete='CASCADE'), nullable=False, index=True)
    account_id = Column(Integer, ForeignKey('accounts.account_id', ondelete='CASCADE'), index=True)
    transaction_id = Column(Integer, ForeignKey('transactions.transaction_id', ondelete='SET NULL'), index=True)
    card_id = Column(Integer, ForeignKey('credit_cards.card_id', ondelete='SET NULL'), index=True)
    
    # AI analysis
    ai_reasoning = Column(JSONB)  # Detailed AI reasoning for the alert
    related_alerts = Column(JSONB)  # References to related alerts
    
    # Status and resolution
    status = Column(SQLEnum(FraudAlertStatus), default=FraudAlertStatus.ACTIVE, index=True)
    is_false_positive = Column(Boolean, default=False)
    is_confirmed_fraud = Column(Boolean, default=False)
    requires_customer_contact = Column(Boolean, default=False)
    
    # Investigation details
    investigated_by = Column(String(100), nullable=True)
    investigation_notes = Column(Text)
    investigation_timestamp = Column(DateTime(timezone=True), nullable=True)
    
    # Resolution details
    resolution_date = Column(DateTime(timezone=True), nullable=True)
    resolution_notes = Column(Text)
    resolution_code = Column(String(50), index=True, nullable=True)
    
    # Impact and actions
    financial_impact = Column(Float, default=0.0)  # Monetary impact if any
    actions_taken = Column(JSONB)  # Actions taken in response to the alert
    
    # Metadata and timestamps
    metadata_ = Column('metadata', JSONB, default=dict)  # For additional attributes
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="fraud_alerts")
    account = relationship("Account", back_populates="fraud_alerts")
    transaction = relationship("Transaction", back_populates="fraud_alerts")
    card = relationship("CreditCard", back_populates="fraud_alerts")
    
    # Indexes
    __table_args__ = (
        Index('idx_alert_user_status', 'user_id', 'status'),
        Index('idx_alert_risk_severity', 'risk_score', 'severity'),
        Index('idx_alert_created', 'created_at'),
        Index('idx_alert_reference', 'alert_reference', unique=True),
        {'extend_existing': True}
    )
    
    def __repr__(self) -> str:
        return f"<FraudAlert {self.alert_reference} ({self.alert_type})>"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert model to dictionary."""
        return {
            'alert_id': self.alert_id,
            'alert_reference': self.alert_reference,
            'alert_type': self.alert_type.value if self.alert_type else None,
            'title': self.title,
            'description': self.description,
            'risk_assessment': {
                'risk_score': self.risk_score,
                'severity': self.severity.value if self.severity else None,
                'confidence': self.confidence,
                'is_false_positive': self.is_false_positive,
                'is_confirmed_fraud': self.is_confirmed_fraud
            },
            'related_entities': {
                'user_id': self.user_id,
                'account_id': self.account_id,
                'transaction_id': self.transaction_id,
                'card_id': self.card_id
            },
            'ai_analysis': {
                'reasoning': self.ai_reasoning,
                'related_alerts': self.related_alerts
            },
            'status_info': {
                'status': self.status.value if self.status else None,
                'requires_customer_contact': self.requires_customer_contact,
                'investigated_by': self.investigated_by,
                'investigation_notes': self.investigation_notes,
                'investigation_timestamp': self.investigation_timestamp.isoformat() if self.investigation_timestamp else None,
                'resolution_date': self.resolution_date.isoformat() if self.resolution_date else None,
                'resolution_notes': self.resolution_notes,
                'resolution_code': self.resolution_code
            },
            'impact': {
                'financial_impact': self.financial_impact,
                'actions_taken': self.actions_taken
            },
            'timestamps': {
                'created_at': self.created_at.isoformat() if self.created_at else None,
                'updated_at': self.updated_at.isoformat() if self.updated_at else None
            },
            'metadata': self.metadata_
        }
    
    def mark_investigating(self, investigator: str, notes: str = None):
        """Mark the alert as under investigation."""
        self.status = FraudAlertStatus.INVESTIGATING
        self.investigated_by = investigator
        self.investigation_timestamp = func.now()
        if notes:
            self.investigation_notes = notes
    
    def mark_false_positive(self, resolution_notes: str = None):
        """Mark the alert as a false positive."""
        self.status = FraudAlertStatus.FALSE_POSITIVE
        self.is_false_positive = True
        self.is_confirmed_fraud = False
        self.resolution_date = func.now()
        self.resolution_notes = resolution_notes or "Marked as false positive"
        self.resolution_code = "FALSE_POSITIVE"
    
    def mark_confirmed_fraud(self, resolution_notes: str = None, financial_impact: float = None):
        """Mark the alert as confirmed fraud."""
        self.status = FraudAlertStatus.CONFIRMED_FRAUD
        self.is_confirmed_fraud = True
        self.is_false_positive = False
        self.resolution_date = func.now()
        self.resolution_notes = resolution_notes or "Confirmed as fraud"
        self.resolution_code = "CONFIRMED_FRAUD"
        if financial_impact is not None:
            self.financial_impact = financial_impact
    
    def add_action(self, action_type: str, description: str, performed_by: str, metadata: dict = None):
        """Add an action taken for this alert."""
        if not self.actions_taken:
            self.actions_taken = []
            
        action = {
            'action_type': action_type,
            'description': description,
            'performed_by': performed_by,
            'timestamp': datetime.utcnow().isoformat(),
            'metadata': metadata or {}
        }
        
        self.actions_taken.append(action)
        return action
